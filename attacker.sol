// SPDX-License-Identifier: MIT LICENSE

pragma solidity ^0.8.0;

interface NFTContract {
    function mintTo(address _to) external;
}

contract Caller {
    uint256 public value;
    address public setter;

    event Log(bool success, bytes calleeSuccess);

    event LogReceiveNFT(
        address operator,
        address from,
        uint256 tokenId,
        bytes data
    );

    function mintByCall(address callee, address _receiverAddress) public {
        // bool _success ;
        // bytes memory data;
        // (bool _success,bytes memory  data) =  callee.call(abi.encodeWithSignature("setValue", _value));
        (bool _success, ) = callee.call(
            abi.encodeWithSignature("mintTo(address)", _receiverAddress)
        );

        require(_success, "Failed to mint NFT");
    }

    function mintByInterface(address callee, address _receiverAddress) public {
        // NFT contract
        NFTContract nftContract = NFTContract(callee);

        nftContract.mintTo(_receiverAddress);
    }

    /**
     * Handler on NFT receive, revert if not preferred id
     */
    function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes calldata data
    ) external returns (bytes4) {
        emit LogReceiveNFT(operator, from, tokenId, data);

        // After get tokenId, two cases to handle:
        // 1. if the tokenId is what i want, then just proceed finish the mint tx
        // 2. if don't want the token, just revert the tx here.

        return 0x150b7a02; // return the magic value bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))
    }
}
